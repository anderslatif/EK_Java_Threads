<div class="title-card">
    <h1>Concurrent Counting</h1>
</div>

---

# Concurrent Counting

This serves to illustrate different ways to handle a shared resource (a counter) in a multithreaded environment.

---

# Create a `ClassicCounter` class

```java
public class ClassicCounter extends Thread {
    private int counter = 0;

    public int getCounter() {
        return counter;
    }

    public void decrement() {
        this.counter--;
    }

    public void increment() {
        this.counter++;
    }
}
```

---

# In `MainCounting`

Let's create two threads as lambdas:

```java
public class MainCounting {
    public static void main(String[] args) throws Exception {

        ClassicCounter classicCounter = new ClassicCounter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                classicCounter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                classicCounter.decrement();
            }
        });

        t1.start();
        t2.start();

        System.out.println(classicCounter.getCounter());

    }
}
```

---

# Observe the output

*What happens and why?*

*What did we expect the output to be?*

---

# The problem

The two threads are accessing and modifying the same variable (`counter`) concurrently without any synchronization.

If both are incrementing and decrementing the same amount, the expected result should be `0`.

As it is now it does the following in the `ClassicCounter` class:

1. Reads the local
2. Increment / decrement value
3. Set the local value

But it's possible that the other thread interferes during this process.

This is what we solved in databases with transactions! Let's see what we can do with threads.

---

# A note on `volatile`

We can define a variable as `volatile` in Java. This ensures that the variable isn't local to a thread but is in the memory of the Main thread.

However, this won't help us in this case, since the problem is not that the counter's value is isolated between threads but that our atomicity requirement is violated.

```java
    // Volatile puts the value in the Main Memory but won't help us here
private volatile int counter = 0;
```

---

<div class="title-card">
    <h1>Synchronized Counter</h1>
</div>

---

# Solution 1: Synchronization

We have already looked at this.

Create the class `SynchronizedCounter`:

```java
public class SynchronizedCounter extends Thread {
    private static Object lock = new Object();

    private int counter = 0;

    public int getCounter() {
        return counter;
    }

/*  // todo solution 1

    public synchronized void decrement() {
        this.counter--;
    }

    public synchronized void increment() {
        this.counter++;
    }*/

    // todo solution 2

    public void decrement() {
        synchronized (lock) {
            this.counter--;
        }
    }

    public void increment() {
        synchronized (lock) {
            this.counter++;
        }
    }
}
```

---

# Two ways to define synchronized

The above example shows that synchronized can be define in the following two ways:

1. It can be given as a keyword to a method

2. A synchronized block can be created inside of a method

---

# In `MainCounting` use `SynchronizedCounter`

Inside of the `main` method in `MainCounting`:

```java
SynchronizedCounter synchronizedCounter = new SynchronizedCounter();

        Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
        synchronizedCounter.increment();
        }
        });

        Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
        synchronizedCounter.decrement();
        }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println(synchronizedCounter.getCounter());

```

*What is the output now?*

---

<div class="title-card">
    <h1>Atomic Counter</h1>
</div>

---

# Solution 2: Atomic Variables

A neat thing is that Java offers atomic variables in the `java.util.concurrent.atomic` package since this is a common use case when multithreading.

The `AtomicInteger` allows us to perform `read-modify-write` operations atomically.

We can do the following:

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCounter extends Thread {
    // 0 = initial value
    private AtomicInteger counter = new AtomicInteger(0);

    public int getCounter() {
        return counter.get();
    }

    public void decrement() {
        this.counter.decrementAndGet();
    }

    public void increment() {
        this.counter.incrementAndGet();
    }
}
```

---

# In the main method of `MainCounting` use `AtomicCounter`

```java
AtomicCounter atomicCounter = new AtomicCounter();

        Thread t1 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
        atomicCounter.increment();
        }
        });

        Thread t2 = new Thread(() -> {
        for (int i = 0; i < 10000; i++) {
        atomicCounter.decrement();
        }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println(atomicCounter.getCounter());
```