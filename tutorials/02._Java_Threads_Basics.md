<div class="title-card">
    <h1>Thread creation - Extends Thread vs. Implements Runnable</h1>
</div>

---

# The Code

You can find the code here:

https://github.com/anderslatif/EK_Java_Threads

The slide decks are named after the folders so this slide deck is contained in the `basics` folder.

You can code along with the slides (recommended) or run the different main methods in the project above.

---

# Remember the two ways to create a thread in Java

1. By extending the `Thread` class

2. By implementing the `Runnable` interface

You **must** override the `run()` method in both cases! This defines the code that will be executed when the thread is started.

---


# Let's implement `Runnable`

```java
public class ThreadImplementsRunnable implements Runnable {

    @Override
    public void run() {
        while (true) {
            System.out.println("Thread is running...");

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

---

# Let's extend `Thread`

```java
public class ThreadExtendsThread extends Thread {
    public void run() {
        for (;;) {
            // print the time
            System.out.println("------------------");
            System.out.println("| " + java.time.LocalTime.now() + " |");
            System.out.println("------------------");
            System.out.println();

        }
    }
}
```

---

# Let's setup the Main class + main method

```java
import java.io.IOException;

public class MainBasics {
    public static void main(String[] args) {
    }
}
```

The following slides will show code to be added inside the `main` method.

---

# In main: Get the Runtime = Java Process

The Runtime class gives us access to the entire JVM process.

```java
Runtime runtime = Runtime.getRuntime();

        System.out.println(runtime.totalMemory());
        System.out.println(runtime.freeMemory());
        System.out.println(runtime.maxMemory());
```

---

# In main: Bonus - Use the Runtime to run an external process

While this is now deprecated since Java 18 and ProcessBuilder is preferred, the point is to illustrate that we can use the Runtime to run external processes.

```java
try {
        String os = System.getProperty("os.name").toLowerCase();
        if (os.contains("win")) {
        runtime.exec("notepad");            // Windows
        } else if (os.contains("mac")) {
        runtime.exec("open -a TextEdit");   // macOS
        } else {
        runtime.exec("gedit");              // Linux (or nano, vim)
        }
        } catch (IOException e) {
        e.printStackTrace();
        }
```

---

# In main: Create and start the thread by implementing Runnable

```java
ThreadImplementsRunnable implementsRunnable = new ThreadImplementsRunnable();
        Thread thread = new Thread(implementsRunnable);
        thread.start();
```

---

# In main: Create and start the thread by extending Thread

```java
ThreadExtendsThread extendsThread = new ThreadExtendsThread();
        ThreadExtendsThread extendsThreadTwo = new ThreadExtendsThread();
        extendsThread.start();
        extendsThreadTwo.start();
```

---

# In main: You can name threads

Naming threads is useful for stack traces, profilers, debuggers and logs.

With Runnable:

```java
ThreadImplementsRunnable implementsRunnable = new ThreadImplementsRunnable();
        Thread thread = new Thread(implementsRunnable, "MyRunnableThread-0");
        thread.start();
```

It is a common practice name threads like: `Thread-0`, `Thread-1` etc.

---

# Exercise: Give names to threads when extending Thread

1. We want to define a constructor for the class `ThreadExtendsThread` that takes a `String` parameter (name).

2. We wish to pass this name to the superclass `Thread` constructor. *How do we call the constructor of a superclass? What keyword do we use?*

This exercise will help you see the relation between extending Thread and implementing Runnable.

---

# Solution: Give names to threads when extending Thread

```java
public class ThreadExtendsThread extends Thread {

    public ThreadExtendsThread(String name) {
        super(name);
    }

    public void run() {
        // Thread logic here
    }
}
```

---

<div class="title-card">
    <h1>Threads as lambdas - Virtual Threads</h1>
</div>

---

# Threads as Lambdas

In the MainBasics `main` method you can create threads using lambda expressions like this:

```java
Thread traditionalThread = new Thread(() -> {
    System.out.println("This runs in a traditional thread" + Thread.currentThread());
});
traditionalThread.start();
```

What is inside of the lambda body is the implementation of the `run()` method from the `Runnable` interface.

---

# Virtual Threads

Instead of the traditional threads which is mapped 1:1 to OS threads, Java now has Virtual Threads which are managed by the JVM. It is significantly more lightweight.

| Traditional Threads | Virtual Threads |
|---------------------|-----------------|
| Maps 1:1 to OS threads | Managed by JVM |
| Heavy (~1MB memory each) | Lightweight (~1KB memory each) |
| Limited to thousands | Millions possible |
| Expensive to create/block | Cheap to create/block |
| Blocking blocks OS thread | Blocking doesn't block OS thread |
| Good for CPU-bound tasks | Perfect for I/O-bound tasks |
| Available since Java 1.0 | Available since Java 19 |

---

# Java Virtual Threads Implementation

This will start on its own:

```java
Thread virtualThread = Thread.startVirtualThread(() -> {
    System.out.println("This runs in a virtual thread" + Thread.currentThread());
});
```

---

# Powerful Example

Let's start a million virtual threads:

```java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    for (int i = 0; i < 1_000_000; i++) {
        executor.submit(() -> {
            try {
                Thread.sleep(Duration.ofSeconds(1));
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Task on: " + Thread.currentThread());
        });
    }
}  // Auto-shutdown
```

This would never be close to possible with traditional threads.

