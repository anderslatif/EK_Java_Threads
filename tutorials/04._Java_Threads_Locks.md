<div class="title-card">
    <h1>Multiple Threads</h1>
</div>

---

# PrintThreads

We will create a class called `PrintThreads` that takes a `String` message to print out one character at a time.

```java
public class PrintThreads extends Thread {
    String message;

    public PrintThreads(String message) {
        this.message = message;
    }

    @Override
    public void run() {
            for (int i = 0; i < message.length(); i++) {
                System.out.print(message.charAt(i));
            }
            System.out.println();
    }
}
```

---

# Create a Main and start the threads

```java
public class MainLocks {
    public static void main(String[] args) {
        PrintThreads thread0 = new PrintThreads("This sentence is so good. Look at it. It's so long and good.");
        PrintThreads thread1 = new PrintThreads("11111111111111111111111111111111111111111111111111111111111111");
        PrintThreads thread2 = new PrintThreads("22222222222222222222222222222222222222222222222222222222222222");
        PrintThreads thread3 = new PrintThreads("The quick brown fox jumps over the lazy dog");

        thread0.start();
        thread1.start();
        thread2.start();
        thread3.start();
    }
}

```

---

# Observe the output

Run the program. *What do you observe?*

Run the program multiple times. *What happens?*

---

# Explanation of the output

The key to understand is that when we start the threads, it does not wait for one thread to finish before proceeding to the next `thread.start()` line.

All threads are started almost simultaneously, and the JVM's thread scheduler decides how to allocate CPU time to each thread. This is different every time.

As a result, the output from different threads gets interleaved, leading to a mixed output on the console.

---

# Solution: Creating a lock + synchronized block

We can create a lock out of any object in Java as long as it is **static** (so that all thread instances can access the same lock). 

We can use this lock in a `synchronized` block. When a thread enters a synchronized block, it acquires the lock. Other threads that try to enter any synchronized block using the same lock will be blocked until the lock is released. The lock is released when the thread exits the synchronized block.

```java
public class PrintThreads extends Thread {
    private static Object lock = new Object();
    String message;

    public PrintThreads(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        synchronized (lock) {
            for (int i = 0; i < message.length(); i++) {
                System.out.print(message.charAt(i));
            }
            System.out.println();
        }
    }
}
```

*What are the drawbacks of this solution?*

---

# Only use synchronization when necessary

Synchronization is for limiting concurrent access to shared resources by making operations [mutually exclusive](https://en.wikipedia.org/wiki/Mutual_exclusion).

But it also creates a bottleneck and may lose us the benefits of concurrency.

Limit its use to only the parts where concurrency problems could occur. 

This is coined as the [critical section](https://en.wikipedia.org/wiki/Critical_section).

---

<div class="title-card">
    <h1>Reentrant Locks</h1>
</div>

---

Another way to acquire a lock and releasing it without using synchronized blocks is through Reentrant locks.

When a reentrant lock is acquired by a thread, the other threads wait until the lock is released.

---

# Create ReentrantLockExample

```java
public class ReentrantLockExample implements Runnable {

    private ReentrantLock reentrantLock = new ReentrantLock();

    @Override
    public void run() {

        reentrantLock.lock();

        for (int i = 0; i <= 100; i++) {
            System.out.println(i);
        }
        reentrantLock.unlock();

    }
}
```

---

# In MainLocks

Add the following inside of the main method:

```java
        ReentrantLockExample reentrantLockExample = new ReentrantLockExample();

        Thread reentrantLockThreadOne = new Thread(reentrantLockExample);
        Thread reentrantLockThreadTwo = new Thread(reentrantLockExample);

        reentrantLockThreadOne.start();
        reentrantLockThreadTwo.start();
```

---


<div class="title-card">
    <h1>Semaphores</h1>
</div>

---

# Semaphores

While a `ReentrantLock` only allows 1 thread to access a resource at a time, `Semaphore` allows us to define a number of permits.

In real life, think of a parking lot with a limited number of parking spaces. When parking you `.acquire()` a permit (a parking space). When you leave you `.release()` the permit.

Or we can imagine trying to access a database with a limited amount of permissible connections in its [thread pool](https://en.wikipedia.org/wiki/Thread_pool).

---

# Create SemaphoreExample

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample implements Runnable {
    Semaphore semaphore;

    public SemaphoreExample(Semaphore semaphore) {
        this.semaphore = semaphore;
    }

    @Override
    public void run() {
        try {
            semaphore.acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


        for (int i = 0; i <= 100; i++) {
            if (i == 60) {
                semaphore.release();
            }
            System.out.println(i);
        }


    }
}
```

---

# In MainLocks

Remember to add the following import:

```java
import java.util.concurrent.Semaphore;
```

And inside of the main method:

```java
        Semaphore semaphore = new Semaphore(1);

        SemaphoreExample semaphoreExample = new SemaphoreExample(semaphore);

        Thread semaphoreThreadOne = new Thread(semaphoreExample);
        Thread semaphoreThreadTwo = new Thread(semaphoreExample);

        semaphoreThreadOne.start();
        semaphoreThreadTwo.start();

        // thread 1: I want to use the resource
        // semaphore = 1 ... -> 0
        // semaphore released 0 -> 1

        // thread 2 I want to use the resource
        // semaphore = 0 ... -> wait until it is higher than 0
        // use the semaphore
```

---

# Observe the result

*What do you see?*

---

# The result

While the result differs with each execution the general behavior is that as soon as the first thread (could be either threadOne or threadTwo) reaches 60 it releases the semaphore at some point and the two threads become interwoven.

